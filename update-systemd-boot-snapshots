#!/bin/bash
#
# File: update-systemd-boot-snapshots
# Project Path: ./update-systemd-boot-snapshots
# Installation Path: /usr/bin/update-systemd-boot-snapshots
#
# Main script for systemd-boot-snapshots for Arch Linux
# Adapted from https://github.com/uszie/systemd-boot-snapshots
#
# This script adds BTRFS snapshots to the systemd-boot menu
# It detects available snapshots and creates boot entries for them
# Works with Timeshift and Snapper snapshots

# Load configuration
if [ -f /etc/default/systemd-boot-snapshots.conf ]; then
  . /etc/default/systemd-boot-snapshots.conf
fi

# Default configuration values
SHOW_SNAPSHOTS_MAX=${SHOW_SNAPSHOTS_MAX:-"99999"}  # Maximum number of snapshots to show
USE_OVERLAYROOT=${USE_OVERLAYROOT:-"true"}         # Whether to use overlay for snapshot boot
SNAPSHOT_PERIOD_TYPE=${SNAPSHOT_PERIOD_TYPE:-"all"} # Type of snapshots to show
VERBOSE=${VERBOSE:-0}                              # Verbosity level

# Constants
timeshift_mount="/run/timeshift/backup"
timeshift_subfolder="timeshift-btrfs/snapshots"
timeshift_snapshots_path="${timeshift_mount}/${timeshift_subfolder}"
sep=";"  # Separator for data processing
NL='
'       # Newline for processing
date_format="+%b %d %Y %H:%M"  # Date format for snapshot display

# Cleanup function - unmounts and removes temporary directories
cleanup() {
  if [ -n "$mount_dir" ]; then
    umount "$mount_dir" 2>/dev/null
    rmdir "$mount_dir" 2>/dev/null
  fi
}

# Set up cleanup on exit
trap cleanup EXIT

# Function to split a string with a separator
# Parameters:
# $1 - separator
# $2 - string to split
# $3+ - variable names to assign parts to
splitsep() {
  local sep="$1"
  local str="$2"
  shift 2
  local tmp

  while [ -n "$str" ] && [ "$#" -gt 1 ]; do
    tmp="${str%%$sep*}"
    eval "$1="'${tmp}'""
    str="${str#"$tmp"}"
    str="${str#$sep}"
    shift
  done

  [ -n "$str" ] && [ -n "$1" ] && eval "$1="'$str'""

  return 0
}

# Check if $1 contains the literal string $2
# Returns true (0) if contained, false (1) otherwise
strstr() {
  [ "${1##*"$2"*}" != "$1" ]
}

# Check if $1 matches the glob pattern $2 completely
# Returns true (0) if matches, false (1) otherwise
strglob() {
  [ -n "$1" ] && [ -z "${1##$2}" ]
}

# Check if $1 contains the glob pattern $2 anywhere
# Returns true (0) if contains, false (1) otherwise
strglobin() {
  [ -n "$1" ] && [ -z "${1##*$2*}" ]
}

# Replace all occurrences of string $2 in string $1 with string $3
# Result is stored in variable $4
str_replace() {
  local in="$1"
  local s="$2"
  local r="$3"
  local out=''

  while strstr "${in}" "$s"; do
    chop="${in%%"$s"*}"
    out="${out}${chop}$r"
    in="${in#*"$s"}"
  done

  eval "$4="'${out}${in}'""
}

# Get the root partition
get_root_partition() {
  mount | grep "on / " | cut -d' ' -f1
}

# Get the UUID of the root partition
get_root_uuid() {
  blkid -s UUID -o value "$(get_root_partition)"
}

# Get the root UUID from a bootloader entry file
get_loader_entry_root_uuid() {
  local _loader_entry="$1"
  grep -o " root=UUID=[^ ]* " "$_loader_entry" | sed 's/.*root=UUID=//'
}

# Create a temporary directory
get_tmp_folder() {
  mktemp -d
}

# Get a configuration property with type checking
# Parameters:
# $1 - property name
# $2 - property type (boolean, integer, string)
# $3 - default value
# $4 - optional config file
get_property() {
  local input=""
  if [ -z "$4" ]; then
    if [ -z "$1" ]; then
      echo "$1 not set! Using $1=$3" >&2
      echo "$3"
      return
    fi

    eval input="$1=\$1"
  elif [ ! -f "$4" ]; then
    echo "$4 not found! Using $1=$3" >&2
    echo "$3"
    return
  else
    input=$(cat "$4")
  fi

  param_value=$(echo "$input" | sed '/^\#/d' | grep "$1" | tail -n 1 |
    cut -d "=" -f2- | sed 's/^[[:space:]]*"\?[[:space:]]*//;s/[[:space:]]*"\?[[:space:]]*$//; s/.*/\L&/')
  if [ -z "$param_value" ]; then
    #parameter not set return default
    echo "$3"
    return
  fi

  if { [ "$2" = "boolean" ] && [ "$param_value" != true ] && [ "$param_value" != false ]; } ||
    { [ "$2" = "integer" ] && ! echo "$param_value" | grep -q -E '^[-+]?[1-9]+ -f "${loader_entries_path}/arch.conf" ]; then
  loader_entry_path="${loader_entries_path}/arch.conf"
else
  # Tenta di trovare qualsiasi file .conf
  entry_files=(${loader_entries_path}/*.conf)
  if [ ${#entry_files[@]} -gt 0 ]; then
    loader_entry_path="${entry_files[0]}"
  else
    echo "Could not find a efi boot entry to use as template, exiting" >&2
    exit 1
  fi
fi

loader_entry_filename="${loader_entry_path##*/}"
loader_entry_filename_base="${loader_entry_filename%.conf}"

if [ -z "$loader_entry_path" ] || [ "$loader_entry_path" = "${loader_entry_path%.conf}" ] || [ ! -r "$loader_entry_path" ]; then
  echo "No suitable boot loader entry found." >&2
  exit 1
fi

# Crea il template per le voci del boot loader
loader_entry_template="$(sed "s/subvol=[^ ,]*/<SUBVOL>/; \
  s/title.*/& <TITLE_SUFFIX>/; \
  /^options.*/ s/$/<OPTIONS>/" <"$loader_entry_path")"

echo "Creating snapshots based on loader entry: $loader_entry_path"

# Ottiene le configurazioni
show_snapshots_max=$(get_property "SHOW_SNAPSHOTS_MAX" "integer" "99999")
use_overlayroot=$(get_property "USE_OVERLAYROOT" "boolean" "true")
snapshot_period_type=$(get_property "SNAPSHOT_PERIOD_TYPE" "string" "all")
if ! echo "$snapshot_period_type" | grep -q '^all$\|^ondemand$\|^boot$\|^hourly$\|^daily$\|^weekly$\|^monthly$'; then
  echo "Wrong paramater in SNAPSHOT_PERIOD_TYPE ($snapshot_period_type). Using SNAPSHOT_PERIOD_TYPE=all" >&2
  snapshot_period_type="all"
fi

# Configura le opzioni per overlayroot
options=""
if [ "$use_overlayroot" != "false" ]; then
  options=" rootovl"
fi

# Monta la partizione root
mount_dir=$(get_tmp_folder)

if ! mount "$root_part" "$mount_dir" -o "ro" -t btrfs; then
  echo "Failed to mount $root_part on $mount_dir"
  exit 1
fi

# Ottiene il subvolume principale
btrfs_subvol_info="$(btrfs subvolume show /)"
btrfs_parent_subvol="${btrfs_subvol_info%%"$NL"*}"
options="$options parent_subvol=$btrfs_parent_subvol"

# Ottiene gli snapshot
snapshots=$({
  get_timeshift_snapshots &
  get_snapper_snapshots &
  wait
})

# Ottiene tutti gli snapshot btrfs
btrfs_snapshots=$(
  btrfs subvolume list -s --sort=-rootid / | awk '{print $14}' |
    (btrfs subvolume list -sa --sort=-rootid / | awk '{print $14}' |
      (paste -d '' /dev/fd/3 /dev/fd/4) 4<&0) 3<&0 | tac
)

# Aggiunge gli snapshot al bootloader
i="1"
for pair in $btrfs_snapshots; do
  btrfs_snapshot="${pair%%"<FS_TREE>"*}"
  btrfs_snapshot_path="${pair##*"<FS_TREE>"}"

  [ "$show_snapshots_max" != "all" ] && [ "$show_snapshots_max" -lt "$i" ] && break # maximum snapshot count reached

  [ -d "${mount_dir}/${btrfs_snapshot_path}/etc" ] || continue # this is not a root snapshot, so skip

  echo "$btrfs_snapshot_path" | grep -q "var/lib/docker" && continue

  [ "$btrfs_snapshot" = "$btrfs_parent_subvol" ] && continue # this is the current/main snapshot, so skip

  snapshot_title="$btrfs_snapshot"
  if has_timeshift || has_snapper; then
    date="", type="", description=""
    if get_snapshot_info_for_subvol "$btrfs_snapshot" "$snapshots" subvolume date type description; then
      snapshot_title="${date}${description:+ $description}${type:+ $type}"
    fi
  fi

  title_suffix="${snapshot_title}"
  snapshot_loader_entry="${loader_entries_path}/${loader_entry_filename_base}-${i}snapshot.conf"

  new=""
  str_replace "$loader_entry_template" "<TITLE_SUFFIX>" "$title_suffix" new
  str_replace "$new" "<SUBVOL>" "subvol=${btrfs_snapshot_path}" new
  str_replace "$new" "<OPTIONS>" "$options" new
  [ "$VERBOSE" -eq 0 ] || echo "Adding loader entry $snapshot_loader_entry"
  echo "$new" >"$snapshot_loader_entry"

  i=$((i + 1))
done

echo "Added $((i - 1)) snapshots to the systemd-boot loader"
; } ||
    { [ "$2" = "string" ] && [ "$param_value" = "" ]; }; then
    echo "Wrong paramater in $1 ($param_value). Using $1=$3" >&2
    param_value="$3"
  fi

  echo "$param_value"
}

# Check if timeshift is installed
has_timeshift() {
  command -v timeshift >/dev/null 2>&1
}

# Check if snapper is installed
has_snapper() {
  command -v snapper >/dev/null 2>&1
}

# Get Timeshift snapshots information
# Returns a list of snapshots with metadata
get_timeshift_snapshots() {
  has_timeshift || return 1

  local _snapshot_date
  local _snapshot_info
  local _folder
  local _folder_name
  
  # Ensure timeshift has mounted the snapshots
  timeshift --list >/dev/null 2>&1
  
  for _folder in "${timeshift_snapshots_path}"/*; do
    [ -e "$_folder" ] || continue
    _folder_name="${_folder##*/}"
    _snapshot_date="$(format_date "$(echo "$_folder_name" | sed 's/ .*//g; s/_/ /; s/-/:/4; s/-/:/3')")"
    _snapshot_info="$(cat "${_folder}/info.json" 2>/dev/null)"
    if [ "${_snapshot_info%type*btrfs*}" != "$_snapshot_info" ]; then
      echo "$_snapshot_info" | grep "comments\|tags" | sort -r |
        sed 's/[[:space:]]*"\(comments\|tags\)"[[:space:]]*:[[:space:]]*"//g; s/",$//g;' |
        sed -e ':a;N;$!ba;' \
          -e "s/\n/${sep}/g; s/ondemand[[:space:]]*/O/; s/boot[[:space:]]*/B/; \
          s/hourly[[:space:]]*/H/; s/daily[[:space:]]*/D/; s/weekly[[:space:]]*/W/; s/monthly[[:space:]]*/M/;" -e \
          "s|^|${timeshift_subfolder}/${_folder_name}/@${sep}$_snapshot_date${sep}|"
    fi
  done
}

# Get Snapper snapshots information
# Returns a list of snapshots with metadata
get_snapper_snapshots() {
  has_snapper || return 1

  local _snapshots
  _snapshots="$(snapper --csvout --separator "$sep" list -a --columns number,subvolume,date,type,description |
    sed -e "1d; /${sep}current/d; /[[:digit:]]\+${sep}\/[^${sep}]/d; s|^\([[:digit:]]\+\)${sep}/|.snapshots/\1/snapshot|")"

  oldIFS="$IFS"
  IFS="$NL"

  for _snapshot in $_snapshots; do
    IFS="$oldIFS"
    local _subvolume
    local _date
    local _type
    local _description
    splitsep "$sep" "$_snapshot" _subvolume _date _type _description
    echo "${_subvolume}${sep}$(format_date "$_date")${sep}${_type}${sep}${_description}"
  done

  IFS="$oldIFS"
}

# Get information for a specific subvolume from snapshot data
# Parameters:
# $1 - subvolume to find
# $2 - snapshots data
# $3+ - variable names to assign parts to
get_snapshot_info_for_subvol() {
  local _subvol="$1"
  local _snapshots="$2"
  local _found

  shift 2
  oldIFS="$IFS"
  IFS="$NL"

  for _snapshot in $_snapshots; do
    IFS="$oldIFS"
    unset "${@#}"
    splitsep "$sep" "$_snapshot" "${@#}"
    eval "_found=$""$1"""
    if [ "$_found" = "$_subvol" ]; then
      return 0
    fi
  done

  IFS="$oldIFS"
  unset "${@#}"

  return 1
}

# Format date according to the defined format
format_date() {
  local _date="$1"
  date -d "$_date" "$date_format" 2>/dev/null || echo "$_date"
}

# Check if running as root
if [ ! "$(id -u)" -eq 0 ]; then
  echo "Please run as root" >&2
  exit 1
fi

# Verify systemd-boot is installed
if ! bootctl is-installed >/dev/null 2>&1; then
  echo "Systemd-boot is not installed on this system. Run bootctl install first" >&2
  exit 1
fi

# Get root partition and UUID
root_part=$(get_root_partition)
if [ -z "$root_part" ]; then
  echo "Could not find root device for /" >&2
  exit 1
fi

root_uuid=$(get_root_uuid)
if [ -z "$root_uuid" ]; then
  echo "Could not find root UUID for /" >&2
  exit 1
fi

# Get OS name and ESP path
os_name=$(grep "^NAME=" /etc/os-release | sed 's/NAME=//; s/"//g')
esp_path=$(bootctl -p)
loader_entries_path="${esp_path}/loader/entries"
{ current_boot_entry="$(cat /proc/cmdline | grep -o "BOOT_IMAGE=.*" | cut -d' ' -f1 | sed 's/BOOT_IMAGE=//g; s/.*\///g')"; } 2>/dev/null
current_boot_entry="${current_boot_entry%.conf}.conf"

# Check if the system is currently booted into a snapshot
# If so, it's not safe to update
if strglob "$current_boot_entry" "-snapshot[0-9]*.conf"; then
  echo "The system is booted into a snapshot, it's not safe to update now, exiting" >&2
  exit 1
fi

# Clean up old snapshot entries from the boot loader
for old_entry in "${loader_entries_path}"/*; do
  [ -r "$old_entry" ] || continue # entry not readable

  # Check if it matches the old style file name format
  # and remove it if it does
  if strglob "$old_entry" "*/${os_name}-snapshot[0-9]*.conf"; then
    [ "$VERBOSE" -eq 0 ] || echo "Removing loader entry $old_entry"
    rm -f "$old_entry"
    continue
  fi

  # Skip if not a snapshot entry
  strglob "$old_entry" "*/*-[0-9]*snapshot.conf" || continue

  old_entry_root_uuid="$(get_loader_entry_root_uuid "$old_entry")"
  [ -n "$old_entry_root_uuid" ] || continue # the UUID of the loader entry is empty, not valid

  [ "$old_entry_root_uuid" != "$root_uuid" ] || continue # the UUID of the root device doesn't match the one in the loader entry, so root filesystem is different

  [ "$VERBOSE" -eq 0 ] || echo "Removing loader entry $old_entry"
  rm -f "$old_entry"
done

# Find the correct entry to use as a template
if [ -f "${loader_entries_path}/${current_boot_entry}" ]; then
  loader_entry_path="${loader_entries_path}/${current_boot_entry}"
elif [ -f "${loader_entries_path}/${os_name}-current.conf" ]; then
  loader_entry_path="${loader_entries_path}/${os_name}-current.conf"
elif [ -f "${loader_entries_path}/arch.conf" ]; then
  loader_entry_path="${loader_entries_path}/arch.conf"
else
  # Attempt to find any .conf file
  entry_files=(${loader_entries_path}/*.conf)
  if [ ${#entry_files[@]} -gt 0 ]; then
    loader_entry_path="${entry_files[0]}"
  else
    echo "Could not find a efi boot entry to use as template, exiting" >&2
    exit 1
  fi
fi

loader_entry_filename="${loader_entry_path##*/}"
loader_entry_filename_base="${loader_entry_filename%.conf}"

if [ -z "$loader_entry_path" ] || [ "$loader_entry_path" = "${loader_entry_path%.conf}" ] || [ ! -r "$loader_entry_path" ]; then
  echo "No suitable boot loader entry found." >&2
  exit 1
fi

# Create template for boot loader entries
loader_entry_template="$(sed "s/subvol=[^ ,]*/<SUBVOL>/; \
  s/title.*/& <TITLE_SUFFIX>/; \
  /^options.*/ s/$/<OPTIONS>/" <"$loader_entry_path")"

echo "Creating snapshots based on loader entry: $loader_entry_path"

# Get configuration values
show_snapshots_max=$(get_property "SHOW_SNAPSHOTS_MAX" "integer" "99999")
use_overlayroot=$(get_property "USE_OVERLAYROOT" "boolean" "true")
snapshot_period_type=$(get_property "SNAPSHOT_PERIOD_TYPE" "string" "all")
if ! echo "$snapshot_period_type" | grep -q '^all$\|^ondemand$\|^boot$\|^hourly$\|^daily$\|^weekly$\|^monthly -f "${loader_entries_path}/arch.conf" ]; then
  loader_entry_path="${loader_entries_path}/arch.conf"
else
  # Tenta di trovare qualsiasi file .conf
  entry_files=(${loader_entries_path}/*.conf)
  if [ ${#entry_files[@]} -gt 0 ]; then
    loader_entry_path="${entry_files[0]}"
  else
    echo "Could not find a efi boot entry to use as template, exiting" >&2
    exit 1
  fi
fi

loader_entry_filename="${loader_entry_path##*/}"
loader_entry_filename_base="${loader_entry_filename%.conf}"

if [ -z "$loader_entry_path" ] || [ "$loader_entry_path" = "${loader_entry_path%.conf}" ] || [ ! -r "$loader_entry_path" ]; then
  echo "No suitable boot loader entry found." >&2
  exit 1
fi

# Crea il template per le voci del boot loader
loader_entry_template="$(sed "s/subvol=[^ ,]*/<SUBVOL>/; \
  s/title.*/& <TITLE_SUFFIX>/; \
  /^options.*/ s/$/<OPTIONS>/" <"$loader_entry_path")"

echo "Creating snapshots based on loader entry: $loader_entry_path"

# Ottiene le configurazioni
show_snapshots_max=$(get_property "SHOW_SNAPSHOTS_MAX" "integer" "99999")
use_overlayroot=$(get_property "USE_OVERLAYROOT" "boolean" "true")
snapshot_period_type=$(get_property "SNAPSHOT_PERIOD_TYPE" "string" "all")
if ! echo "$snapshot_period_type" | grep -q '^all$\|^ondemand$\|^boot$\|^hourly$\|^daily$\|^weekly$\|^monthly$'; then
  echo "Wrong paramater in SNAPSHOT_PERIOD_TYPE ($snapshot_period_type). Using SNAPSHOT_PERIOD_TYPE=all" >&2
  snapshot_period_type="all"
fi

# Configura le opzioni per overlayroot
options=""
if [ "$use_overlayroot" != "false" ]; then
  options=" rootovl"
fi

# Monta la partizione root
mount_dir=$(get_tmp_folder)

if ! mount "$root_part" "$mount_dir" -o "ro" -t btrfs; then
  echo "Failed to mount $root_part on $mount_dir"
  exit 1
fi

# Ottiene il subvolume principale
btrfs_subvol_info="$(btrfs subvolume show /)"
btrfs_parent_subvol="${btrfs_subvol_info%%"$NL"*}"
options="$options parent_subvol=$btrfs_parent_subvol"

# Ottiene gli snapshot
snapshots=$({
  get_timeshift_snapshots &
  get_snapper_snapshots &
  wait
})

# Ottiene tutti gli snapshot btrfs
btrfs_snapshots=$(
  btrfs subvolume list -s --sort=-rootid / | awk '{print $14}' |
    (btrfs subvolume list -sa --sort=-rootid / | awk '{print $14}' |
      (paste -d '' /dev/fd/3 /dev/fd/4) 4<&0) 3<&0 | tac
)

# Aggiunge gli snapshot al bootloader
i="1"
for pair in $btrfs_snapshots; do
  btrfs_snapshot="${pair%%"<FS_TREE>"*}"
  btrfs_snapshot_path="${pair##*"<FS_TREE>"}"

  [ "$show_snapshots_max" != "all" ] && [ "$show_snapshots_max" -lt "$i" ] && break # maximum snapshot count reached

  [ -d "${mount_dir}/${btrfs_snapshot_path}/etc" ] || continue # this is not a root snapshot, so skip

  echo "$btrfs_snapshot_path" | grep -q "var/lib/docker" && continue

  [ "$btrfs_snapshot" = "$btrfs_parent_subvol" ] && continue # this is the current/main snapshot, so skip

  snapshot_title="$btrfs_snapshot"
  if has_timeshift || has_snapper; then
    date="", type="", description=""
    if get_snapshot_info_for_subvol "$btrfs_snapshot" "$snapshots" subvolume date type description; then
      snapshot_title="${date}${description:+ $description}${type:+ $type}"
    fi
  fi

  title_suffix="${snapshot_title}"
  snapshot_loader_entry="${loader_entries_path}/${loader_entry_filename_base}-${i}snapshot.conf"

  new=""
  str_replace "$loader_entry_template" "<TITLE_SUFFIX>" "$title_suffix" new
  str_replace "$new" "<SUBVOL>" "subvol=${btrfs_snapshot_path}" new
  str_replace "$new" "<OPTIONS>" "$options" new
  [ "$VERBOSE" -eq 0 ] || echo "Adding loader entry $snapshot_loader_entry"
  echo "$new" >"$snapshot_loader_entry"

  i=$((i + 1))
done

echo "Added $((i - 1)) snapshots to the systemd-boot loader"
; then
  echo "Wrong paramater in SNAPSHOT_PERIOD_TYPE ($snapshot_period_type). Using SNAPSHOT_PERIOD_TYPE=all" >&2
  snapshot_period_type="all"
fi

# Configure overlay options based on initramfs system
options=""
if [ "$use_overlayroot" != "false" ]; then
  # Determine the type of initramfs used
  if [ -d "/usr/lib/dracut" ] || command -v dracut >/dev/null 2>&1; then
    # For dracut
    options=" rootovl"
  else
    # For mkinitcpio (default in Arch)
    options=" rootovl"
  fi
fi

# Mount the root partition for snapshot detection
mount_dir=$(get_tmp_folder)

if ! mount "$root_part" "$mount_dir" -o "ro" -t btrfs; then
  echo "Failed to mount $root_part on $mount_dir"
  exit 1
fi

# Get the parent subvolume info
btrfs_subvol_info="$(btrfs subvolume show /)"
btrfs_parent_subvol="${btrfs_subvol_info%%"$NL"*}"
options="$options parent_subvol=$btrfs_parent_subvol"

# Get snapshots from Timeshift and Snapper
snapshots=$({
  get_timeshift_snapshots &
  get_snapper_snapshots &
  wait
})

# Get all BTRFS snapshots
btrfs_snapshots=$(
  btrfs subvolume list -s --sort=-rootid / | awk '{print $14}' |
    (btrfs subvolume list -sa --sort=-rootid / | awk '{print $14}' |
      (paste -d '' /dev/fd/3 /dev/fd/4) 4<&0) 3<&0 | tac
)

# Add snapshots to the bootloader
i="1"
for pair in $btrfs_snapshots; do
  btrfs_snapshot="${pair%%"<FS_TREE>"*}"
  btrfs_snapshot_path="${pair##*"<FS_TREE>"}"

  # Check maximum snapshot count
  [ "$show_snapshots_max" != "all" ] && [ "$show_snapshots_max" -lt "$i" ] && break

  # Check if snapshot contains /etc (needed for root snapshots)
  [ -d "${mount_dir}/${btrfs_snapshot_path}/etc" ] || continue

  # Skip Docker container snapshots
  echo "$btrfs_snapshot_path" | grep -q "var/lib/docker" && continue

  # Skip the current/main snapshot
  [ "$btrfs_snapshot" = "$btrfs_parent_subvol" ] && continue

  # Get snapshot title from metadata if available
  snapshot_title="$btrfs_snapshot"
  if has_timeshift || has_snapper; then
    date="", type="", description=""
    if get_snapshot_info_for_subvol "$btrfs_snapshot" "$snapshots" subvolume date type description; then
      snapshot_title="${date}${description:+ $description}${type:+ $type}"
    fi
  fi

  # Create the bootloader entry
  title_suffix="${snapshot_title}"
  snapshot_loader_entry="${loader_entries_path}/${loader_entry_filename_base}-${i}snapshot.conf"

  new=""
  str_replace "$loader_entry_template" "<TITLE_SUFFIX>" "$title_suffix" new
  str_replace "$new" "<SUBVOL>" "subvol=${btrfs_snapshot_path}" new
  str_replace "$new" "<OPTIONS>" "$options" new
  [ "$VERBOSE" -eq 0 ] || echo "Adding loader entry $snapshot_loader_entry"
  echo "$new" >"$snapshot_loader_entry"

  i=$((i + 1))
done

echo "Added $((i - 1)) snapshots to the systemd-boot loader" -f "${loader_entries_path}/arch.conf" ]; then
  loader_entry_path="${loader_entries_path}/arch.conf"
else
  # Tenta di trovare qualsiasi file .conf
  entry_files=(${loader_entries_path}/*.conf)
  if [ ${#entry_files[@]} -gt 0 ]; then
    loader_entry_path="${entry_files[0]}"
  else
    echo "Could not find a efi boot entry to use as template, exiting" >&2
    exit 1
  fi
fi

loader_entry_filename="${loader_entry_path##*/}"
loader_entry_filename_base="${loader_entry_filename%.conf}"

if [ -z "$loader_entry_path" ] || [ "$loader_entry_path" = "${loader_entry_path%.conf}" ] || [ ! -r "$loader_entry_path" ]; then
  echo "No suitable boot loader entry found." >&2
  exit 1
fi

# Crea il template per le voci del boot loader
loader_entry_template="$(sed "s/subvol=[^ ,]*/<SUBVOL>/; \
  s/title.*/& <TITLE_SUFFIX>/; \
  /^options.*/ s/$/<OPTIONS>/" <"$loader_entry_path")"

echo "Creating snapshots based on loader entry: $loader_entry_path"

# Ottiene le configurazioni
show_snapshots_max=$(get_property "SHOW_SNAPSHOTS_MAX" "integer" "99999")
use_overlayroot=$(get_property "USE_OVERLAYROOT" "boolean" "true")
snapshot_period_type=$(get_property "SNAPSHOT_PERIOD_TYPE" "string" "all")
if ! echo "$snapshot_period_type" | grep -q '^all$\|^ondemand$\|^boot$\|^hourly$\|^daily$\|^weekly$\|^monthly$'; then
  echo "Wrong paramater in SNAPSHOT_PERIOD_TYPE ($snapshot_period_type). Using SNAPSHOT_PERIOD_TYPE=all" >&2
  snapshot_period_type="all"
fi

# Configura le opzioni per overlayroot
options=""
if [ "$use_overlayroot" != "false" ]; then
  options=" rootovl"
fi

# Monta la partizione root
mount_dir=$(get_tmp_folder)

if ! mount "$root_part" "$mount_dir" -o "ro" -t btrfs; then
  echo "Failed to mount $root_part on $mount_dir"
  exit 1
fi

# Ottiene il subvolume principale
btrfs_subvol_info="$(btrfs subvolume show /)"
btrfs_parent_subvol="${btrfs_subvol_info%%"$NL"*}"
options="$options parent_subvol=$btrfs_parent_subvol"

# Ottiene gli snapshot
snapshots=$({
  get_timeshift_snapshots &
  get_snapper_snapshots &
  wait
})

# Ottiene tutti gli snapshot btrfs
btrfs_snapshots=$(
  btrfs subvolume list -s --sort=-rootid / | awk '{print $14}' |
    (btrfs subvolume list -sa --sort=-rootid / | awk '{print $14}' |
      (paste -d '' /dev/fd/3 /dev/fd/4) 4<&0) 3<&0 | tac
)

# Aggiunge gli snapshot al bootloader
i="1"
for pair in $btrfs_snapshots; do
  btrfs_snapshot="${pair%%"<FS_TREE>"*}"
  btrfs_snapshot_path="${pair##*"<FS_TREE>"}"

  [ "$show_snapshots_max" != "all" ] && [ "$show_snapshots_max" -lt "$i" ] && break # maximum snapshot count reached

  [ -d "${mount_dir}/${btrfs_snapshot_path}/etc" ] || continue # this is not a root snapshot, so skip

  echo "$btrfs_snapshot_path" | grep -q "var/lib/docker" && continue

  [ "$btrfs_snapshot" = "$btrfs_parent_subvol" ] && continue # this is the current/main snapshot, so skip

  snapshot_title="$btrfs_snapshot"
  if has_timeshift || has_snapper; then
    date="", type="", description=""
    if get_snapshot_info_for_subvol "$btrfs_snapshot" "$snapshots" subvolume date type description; then
      snapshot_title="${date}${description:+ $description}${type:+ $type}"
    fi
  fi

  title_suffix="${snapshot_title}"
  snapshot_loader_entry="${loader_entries_path}/${loader_entry_filename_base}-${i}snapshot.conf"

  new=""
  str_replace "$loader_entry_template" "<TITLE_SUFFIX>" "$title_suffix" new
  str_replace "$new" "<SUBVOL>" "subvol=${btrfs_snapshot_path}" new
  str_replace "$new" "<OPTIONS>" "$options" new
  [ "$VERBOSE" -eq 0 ] || echo "Adding loader entry $snapshot_loader_entry"
  echo "$new" >"$snapshot_loader_entry"

  i=$((i + 1))
done

echo "Added $((i - 1)) snapshots to the systemd-boot loader"
